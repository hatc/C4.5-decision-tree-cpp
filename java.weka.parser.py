#!/usr/bin/python
# encoding=windows-1251
# java.weka.parser.py - parse Java source generated by weka.classifiers.trees.J48
# with ANTLR 3 and translate it to C++ code, cpcl::CsvReader used for parse input data
# Copyright (C) 2012-2013 Yuri Agafonov
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import sys
from os import getcwd
sys.path.append(getcwd())

import antlr3
import JavaLexer
import JavaParser

def ASTypeName(ast_type):
	if getattr(JavaLexer, 'AST_TYPE_2_NAME', None) is None:
		type2name = {}
		name2type = {}
		lexer_globals = set(dir(JavaLexer)).difference(set(dir(antlr3)))
		lexer_globals.discard('HIDDEN')
		for i in lexer_globals:
			attr = getattr(JavaLexer, i)
			if type(attr) == int:
				type2name[attr] = i
				name2type[i] = attr
		setattr(JavaLexer, 'AST_TYPE_2_NAME', type2name)
		setattr(JavaLexer, 'AST_NAME_2_TYPE', name2type)
	return JavaLexer.AST_TYPE_2_NAME[ast_type]

def __visit__(tree, ast_type, f):
	for i in tree.children:
		if i.getType() == ast_type:
			if f(i):
				return True
		if i.children:
			if __visit__(i, ast_type, f):
				return True

def Visit(tree, ast_type, f):
	__visit__(tree, ast_type, getattr(f, 'Visit' + ''.join(map(lambda s:s.lower().capitalize(), ASTypeName(ast_type).split('_'))), f))
	
from sys import exc_info
class ASTError(Exception):
	def __init__(self, expr):
		self.expr = expr
	def __str__(self):
		return self.expr

# relative path, i.e. for select Node2 from tree:
# Node0
#  Node1
#   Node2 Node3
#  Node4
#  Node5
# use Path(tree, 'Node1.Node2'), not a Path(tree, 'Node0.Node1.Node2') - parent node(tree node) not included in relative path
def __path__(tree, p, throw): #exception = False):
	for i in p:
		n = 0
		if isinstance(i, (tuple, list)):
			n = i[1]
			i = i[0]
		r = None
		for node in tree.children:
			if i is None or node.getType() == i: # *[1] - select any second children node
				if n:
					n -= 1
				else:
					r = node
					break
		if r:
			tree = r
		elif throw:
			raise ASTError('invalid node: no <%s> children' % ASTypeName(i))
			# raise Exception('invalid node: no <%s> children' % ASTypeName(i))
		else:
			return None
	return tree

import re
def __pathquery__(query):
	# можно конечно ASTNameType добавить, но она используется только Path...
	if getattr(JavaLexer, 'AST_NAME_2_TYPE', None) is None:
		ASTypeName(JavaLexer.CLASS)
	regex = re.compile(r'(?P<ast_type>[A-Z_*]+)\[(?P<n>[0-9]+)\]')
	p = []
	for i in query.split('.'):
		m = regex.match(i)
		if m:
			p.append((JavaLexer.AST_NAME_2_TYPE.get(m.group('ast_type')), int(m.group('n'))))
		else:
			p.append(JavaLexer.AST_NAME_2_TYPE.get(i))
	return p

def Path(tree, query):
	p = __pathquery__(query)
	return __path__(tree, p, False)
def PathText(tree, query):
	p = __pathquery__(query)
	# return __path__(tree, p, True).toString()
	return str(__path__(tree, p, True).toString()) # can be unicode

def FindChild(node, f):
	if node:
		for i in node.children:
			if f(i):
				return i
	return None

def Parse(filepath, encoding = None):
	stream = antlr3.ANTLRFileStream(filepath, encoding)
	lexer = JavaLexer.JavaLexer(stream)
	tokens_stream = antlr3.CommonTokenStream(lexer)
	parser = JavaParser.JavaParser(tokens_stream)
	return parser.javaSource().getTree()

class InstanceDict(dict):
	'dictionary of item_index(int) : item_type(str)'
	
	def add(self, index, v):
		assert v in ('String', 'Double')
		#if self.get(index, v) != v:
		#	raise ASTError('different types for attribute %d' % index)
		#self[index] = v
		value = self.get(index)
		if value is None:
			self[index] = v
		elif value != v:
			raise ASTError('different types(%s, %s) for attribute %d' % (value, v, index))
	
	IDENT_CHAR = ' '
	#INSTANCE_VARIABLE_TYPE = 'Instance const &'
	INSTANCE_VARIABLE_TYPE = 'Instance'
	#INSTANCE_VARIABLE_NAME = 'items'
	INSTANCE_VARIABLE_NAME = 'i'
	def generate_selector(self, index):
		v = len(self) - 1
		places = 1
		while v > 9:
			v /= 10
			places += 1
		return ('%s.item%%0%uu' % (InstanceDict.INSTANCE_VARIABLE_NAME, places)) % index
		
	def generate_null_items_test(self, index):
		return '%s.null_items.test(%u)' % (InstanceDict.INSTANCE_VARIABLE_NAME, index)
	def generate_null_items_set(self, index):
		return '%s.null_items.set(%u)' % (InstanceDict.INSTANCE_VARIABLE_NAME, index)
	
	def generate_literal(self, index, literal):
		if self[index] == 'String':
			return 'cpcl::StringPieceFromLiteral("%s")' % literal # seems as all obj with method __str__ can be formatted as %s
		else:
			return str(literal)
			
	def write(self, out, ident):
		out.write('%sstruct %s {\n' % (InstanceDict.IDENT_CHAR * ident, InstanceDict.INSTANCE_VARIABLE_TYPE))
		out.write('%sstd::bitset<%d> null_items;\n\n' % (InstanceDict.IDENT_CHAR * (ident + 1), max(self.keys()) + 1))
		v = len(self) - 1
		places = 1
		while v > 9:
			v /= 10
			places += 1
		item_format = '%s%%s item%%0%uu;\n' % (InstanceDict.IDENT_CHAR * (ident + 1), places)
		for i in sorted(self.keys()):
			out.write(item_format % ('double' if self[i] == 'Double' else 'cpcl::StringPiece', i))
		out.write('};')
		
import codecs
class LiteralExpr(object):
	'''
	UNARY_MINUS
	 FLOATING_POINT_LITERAL: '0.717175'
	
	||
	
	DECIMAL_LITERAL: '2'
	
	||
	
	STRING_LITERAL: '"Sunny"'
	'''
	def __init__(self, node):
		prefix = ''
		if node.getType() in (JavaLexer.UNARY_MINUS, JavaLexer.UNARY_PLUS):
			if node.getType() == JavaLexer.UNARY_MINUS:
				prefix = '-'
			node = Path(node, '*')
		if node is None or not ASTypeName(node.getType()).endswith('_LITERAL'):	
			raise ASTError('ast for literal_expressions')
		self.literal = prefix + node.toString()
		node_type = node.getType()
		if node_type == JavaLexer.OCTAL_LITERAL:
			self.radix = 8
		elif node_type == JavaLexer.DECIMAL_LITERAL:
			self.radix = 10
		elif node_type == JavaLexer.HEX_LITERAL:
			self.radix = 16
		elif node_type == JavaLexer.FLOATING_POINT_LITERAL:
			self.radix = -1
		else:
			'string or char literal'
			#	if isinstance(s, unicode): s = codecs.lookup('windows-1251').encode(s)[0]; return ''.join('\\x%02x' % ord(c) if ord(c) > 127 else c for c in s)
			if isinstance(self.literal, unicode): # parser with antlr3.ANTLRFileStream(filepath, 'utf-16') returns ast with type(Node.toString()) == unicode
				self.literal = ''.join('\\x%02x' % ord(c) if ord(c) > 127 else c for c in codecs.lookup('windows-1251').encode(self.literal)[0])
	
	def __int__(self):
		'convert octal/decimal/hex literals'
		if not hasattr(self, 'radix'):
			raise ASTError("invalid literal for int(): '%s'" % self.literal) #ValueError("invalid literal for int(): '%s'" % self.literal)
		return int(self.literal, self.radix) if self.radix > 0 else int(float(self.literal))
	
	def __str__(self):
		'for numeric literals returns unchanged literal, for string literal strip quotes'
		return self.literal if hasattr(self, 'radix') else self.literal.strip('\'"')

#PathLiteralExpr = lambda tree, query:LiteralExpr(__path__(tree, __pathquery__(query), True))
def PathLiteralExpr(tree, query):
	return LiteralExpr(__path__(tree, __pathquery__(query), True))
'define two version: 1) with simple LiteralExprStmt and use PathText for DECIMAL_LITERAL and STRING_LITERAL 2) with LiteralExpr object supports unicode literals and PathLiteralExpr for all literal expr'
'''def PathLiteralExpr(tree, query):
	return LiteralExpr(__path__(tree, __pathquery__(query), True))
class LiteralExpr(object):
	@staticmethod
	def FromPath(tree, query):
		return LiteralExpr(__path__(tree, __pathquery__(query), True))'''

def LiteralExprStmt(node):
	'''
	UNARY_MINUS
	 FLOATING_POINT_LITERAL: '0.717175'
	
	||
	
	DECIMAL_LITERAL: '2'
	'''
	prefix = ''
	if node.getType() in (JavaLexer.UNARY_MINUS, JavaLexer.UNARY_PLUS):
		if node.getType() == JavaLexer.UNARY_MINUS:
			prefix = '-'
		node = Path(node, '*')
	if node is None or not ASTypeName(node.getType()).endswith('_LITERAL'):
		raise ASTError('ast for literal_expressions')
	return prefix + node.toString()
	#node_type = node.getType()
	#if node_type == JavaLexer.STRING_LITERAL:
	#	s = node.toString()
	#	if isinstance(s, unicode): s = codecs.lookup('windows-1251').encode(s)[0]; return ''.join('\\x%02x' % ord(c) if ord(c) > 127 else c for c in s)
	#
	# c++ supports same literals, so it's no point to convert them to decimal - yeah, but array index needed as int
	#if node_type == JavaLexer.OCTAL_LITERAL:
	#	return prefix + str(int(node.toString(), 8))
	#elif node_type == JavaLexer.HEX_LITERAL:
	#	return prefix + str(int(node.toString(), 16))
	#return prefix + node.toString()	

def AssignmentExprStmt(node, java_class_name):
	'''
	BLOCK_SCOPE
	 EXPR
	  ASSIGN
	   IDENT: 'p'
	   DECIMAL_LITERAL: '0'
	   
	||
	
	BLOCK_SCOPE
	 EXPR
	  ASSIGN
	   IDENT: 'p'
	   METHOD_CALL
	    DOT
	     IDENT: 'WekaJ48Classifier'
	     IDENT: 'Nbf8cf51'
	    ARGUMENT_LIST
	     EXPR
	      IDENT: 'i'
	'''
	node = FindChild(Path(node, 'EXPR.ASSIGN'), lambda i:i.getType() != JavaLexer.IDENT)
	if node and node.getType() == JavaLexer.METHOD_CALL:
		node = FindChild(Path(node, 'DOT'), lambda i:i.getType() == JavaLexer.IDENT and i.toString() != java_class_name)
	if node is None:
		raise ASTError('ast for assignment_statement')
		
	if node.getType() == JavaLexer.IDENT:
		return 'return %s(%s);' % (str(node.toString()), InstanceDict.INSTANCE_VARIABLE_NAME)
	else:
		# return 'return %s;' % LiteralExprStmt(node) # raise ASTError if can't find literal in given tree
		return 'return %s;' % str(LiteralExpr(node)) # raise ASTError if can't find literal in given tree

class IfExpr(object):
	'''
	METHOD_CALL
	 DOT
	  ARRAY_ELEMENT_ACCESS
	   IDENT: 'i'
	   EXPR
	    DECIMAL_LITERAL: '1'
	  IDENT: 'equals'
	 ARGUMENT_LIST
	  EXPR
	   STRING_LITERAL: '"Sunny"'
	'''
	def __init__(self, node, instance):
		'can use base __init__ as IfExpr.__init__(self, node, instance)'
		self.instance = instance
		self.assignment_stmt = None
		if node is None: # called by derived __init__ method, perform only basic attr initialization
			return
		# in java if array index less than zero, then an ArrayIndexOutOfBoundsException is thrown
		# so, no need for LiteralExprF conversion - yeah but what if array index not a decimal literal ?
		# self.index = int(PathText(node, 'DOT.ARRAY_ELEMENT_ACCESS.EXPR.DECIMAL_LITERAL'))
		self.index = int(PathLiteralExpr(node, 'DOT.ARRAY_ELEMENT_ACCESS.EXPR.*'))
		# self.index = int(LiteralExpr(__path__(node, __pathquery__('DOT.ARRAY_ELEMENT_ACCESS.EXPR.*'), True)))
		if PathText(node, 'DOT.IDENT') != 'equals':
			raise ASTError("ast for if_statement('Object.%s')" % PathText(node, 'DOT.IDENT'))
		self.literal = str(PathLiteralExpr(node, 'ARGUMENT_LIST.EXPR.STRING_LITERAL'))
		self.instance.add(self.index, 'String')
		# PathText and InstanceDict.add throws ASTError - all ASTError catched with traceback and method name
	
	def if_stmt(self):
		'''virtual
		"%self.instance.generate_selector(self.index) == %self.instance.generate_literal(self.index)"
		i.e. str with only condition expression
		full multiline statement generated by write(out, ident) method
		'''
		return '%s == %s' % (self.instance.generate_selector(self.index), self.instance.generate_literal(self.index, self.literal))
	
	def write(self, out, new_line_ident):
		'overloading working, so may override only generate_if_expr / if_stmt'
		out.write('if (%s) {\n' % self.if_stmt())
		out.write('%s%s\n' % (InstanceDict.IDENT_CHAR * (new_line_ident + 1), self.assignment_stmt))
		out.write('%s}' % (InstanceDict.IDENT_CHAR * new_line_ident))

class IfNullExpr(IfExpr):
	'''
	EQUAL
	 ARRAY_ELEMENT_ACCESS
	  IDENT: 'i'
	  EXPR
	   DECIMAL_LITERAL: '2'
	 NULL	
	'''
	def __init__(self, node, instance):
		IfExpr.__init__(self, None, instance)
		self.index = int(PathLiteralExpr(node, 'ARRAY_ELEMENT_ACCESS.EXPR.*'))
		if Path(node, 'NULL') is None:
			raise ASTError('ast for if_statement')
	
	def if_stmt(self):
		'''virtual
		"i.null_items.test(self.index))"
		'''
		return '%s' % self.instance.generate_null_items_test(self.index)

class IfCompareExpr(IfExpr):
	'''
	LESS_THAN | LESS_OR_EQUAL | GREATER_THAN | GREATER_OR_EQUAL
	 METHOD_CALL
	  DOT
	   PARENTESIZED_EXPR
	    EXPR
	     CAST_EXPR
	      TYPE
	       QUALIFIED_TYPE_IDENT
	        IDENT: 'Double'
	      ARRAY_ELEMENT_ACCESS
	       IDENT: 'i'
	       EXPR
	        DECIMAL_LITERAL: '2'
	   IDENT: 'doubleValue'
	  ARGUMENT_LIST
	 UNARY_MINUS
	  FLOATING_POINT_LITERAL: '10.214612'
	'''
	def __init__(self, node, instance):
		IfExpr.__init__(self, None, instance)
		self.comp_operator = str(node.toString())
		#iterator = zip(node.children, [JavaLexer.METHOD_CALL, JavaLexer.METHOD_CALL])
		#node = None
		#for i, t in iterator:#zip(node.children, [JavaLexer.METHOD_CALL, JavaLexer.METHOD_CALL]):
		#	if i.getType() == t:
		#		node = i
		#	else:
		#		self.literal = LiteralExprStmt(i)
		if len(node.children) == 2:
			if node.children[0].getType() == JavaLexer.METHOD_CALL:
				# self.literal = LiteralExprStmt(node.children[1])
				self.literal = str(LiteralExpr(node.children[1]))
				node = node.children[0]
			elif node.children[1].getType() == JavaLexer.METHOD_CALL:
				# self.literal = LiteralExprStmt(node.children[0])
				self.literal = str(LiteralExpr(node.children[0]))
				node = node.children[1]
			else:
				node = None
		else:
			node = None
		if node is None:
			raise ASTError('ast for if_statement')
		# self.index = int(PathText(node, 'DOT.PARENTESIZED_EXPR.EXPR.CAST_EXPR.ARRAY_ELEMENT_ACCESS.EXPR.DECIMAL_LITERAL'))
		self.index = int(PathLiteralExpr(node, 'DOT.PARENTESIZED_EXPR.EXPR.CAST_EXPR.ARRAY_ELEMENT_ACCESS.EXPR.*'))
		self.instance.add(self.index, 'Double')
		
	def if_stmt(self):
		'''virtual
		"%self.instance.generate_selector(self.index) %self.comp_operator %self.instance.generate_literal(self.index)"
		'''
		return '%s %s %s' % (self.instance.generate_selector(self.index), self.comp_operator, self.instance.generate_literal(self.index, self.literal))

class MethodExpr(object):
	def __init__(self, method_name, instance):
		self.instance = instance
		self.method_name = method_name
		self.if_expr_chain = []
	
	def write(self, out, ident):
		'inline double %method_name(Instance const &%InstanceDict.INSTANCE_VARIABLE_NAME) { ... }#write only method, not eol nor space'
		out.write('%sinline double %s(%s const &%s) {\n' % (InstanceDict.IDENT_CHAR * ident, self.method_name, InstanceDict.INSTANCE_VARIABLE_TYPE, InstanceDict.INSTANCE_VARIABLE_NAME))
		if len(self.if_expr_chain) > 0:
			out.write('%s' % (InstanceDict.IDENT_CHAR * (ident + 1)))
			self.if_expr_chain.pop(0).write(out, ident + 1)
			for if_expr in self.if_expr_chain:
				out.write(' else ')
				if_expr.write(out, ident + 1)
			out.write('\n')
		out.write('%sreturn std::numeric_limits<double>::quiet_NaN();\n' % (InstanceDict.IDENT_CHAR * (ident + 1)))
		out.write('%s}' % (InstanceDict.IDENT_CHAR * ident))

class Visitor(object):
	def __init__(self, java_class_name):
		self.java_class_name = java_class_name
		self.instance = InstanceDict()
		self.method_chain = []
		self.entry_point = None
	
	def ParseIfExpr(self, node):
		node_type = node.getType()
		if node_type == JavaLexer.METHOD_CALL:
			return IfExpr(node, self.instance) # item[n].equals(STRING_LITERAL)
		elif node_type == JavaLexer.EQUAL:
			return IfNullExpr(node, self.instance) # item[n] == null
		elif node_type in (JavaLexer.LESS_THAN, JavaLexer.LESS_OR_EQUAL, JavaLexer.GREATER_THAN, JavaLexer.GREATER_OR_EQUAL):
			return IfCompareExpr(node, self.instance) # ((Double)item[n]).doubleValue() { '<' | '<=' | '>' | '>=' } [{ UNARY_MINUS | UNARY_PLUS }] FLOATING_POINT_LITERAL
		else:
			raise ASTError('ast')
	
	def VisitIf(self, node):
		method_expr = self.method_chain[-1]
		try:
			expr_node = Path(node, 'PARENTESIZED_EXPR.EXPR.*')
			block_node = Path(node, 'BLOCK_SCOPE')
			if expr_node is None or block_node is None:
				raise ASTError('ast')
			
			expr = self.ParseIfExpr(expr_node)
			#expr.assignment_stmt = str(AssignmentExpr(block_node, self.java_class_name))
			expr.assignment_stmt = AssignmentExprStmt(block_node, self.java_class_name)
			method_expr.if_expr_chain.append(expr)
		except ASTError as e:
			raise Exception('%s for method %s.%s is unexpected' % (e.expr, self.java_class_name, method_expr.method_name)), None, exc_info()[2]
	
	def VisitFunctionMethodDecl(self, node):
		method_name = PathText(node, 'IDENT')
		if method_name == 'classify':
			assert self.entry_point is None
			node = FindChild(Path(node, 'BLOCK_SCOPE.EXPR.ASSIGN.METHOD_CALL.DOT'), lambda i:i.getType() == JavaLexer.IDENT and i.toString() != self.java_class_name)
			if node:
				self.entry_point = str(node.toString())
			#tmp_node = Path(node, 'BLOCK_SCOPE.EXPR.ASSIGN.METHOD_CALL.DOT')
			#if tmp_node:
			#	for i in tmp_node.children:
			#		if i.getType() == JavaLexer.IDENT and i.toString() != self.java_class_name:
			#			self.entry_point = i.toString()
			#			break
			if not self.entry_point: # why not 'if self.entry_point is None' ? yeah, empty string '' also invalid as entry_point
				raise Exception('ast for method %s.classify is unexpected' % self.java_class_name)
		else:
			self.method_chain.append(MethodExpr(method_name, self.instance))
			Visit(node, JavaLexer.IF, self)
		# return None == return False, i.e. continue iteration over method's list
	
	def VisitClass(self, node):
		if self.java_class_name == PathText(node, 'IDENT'):
			Visit(node, JavaLexer.FUNCTION_METHOD_DECL, self)
			return True

from os.path import basename
def filename(filepath):
	s = basename(filepath)
	i = s.rfind('.')
	if (i > 0):
		s = s[:i]
	return s

def main():
	assert len(sys.argv) > 1
	tree = Parse(sys.argv[1], None) #Parse('TestClass.utf-16.java', 'utf-16')
	visitor = Visitor(sys.argv[2] if len(sys.argv) > 2 else filename(sys.argv[1])) #Visitor('WekaJ48Classifier')
	Visit(tree, JavaLexer.CLASS, visitor)
	assert len(visitor.method_chain) > 0
	with open('main.cpp', 'w') as f: #open('TestClass.utf-16.cpp', 'w')
		f.write('''#include <memory>
#include <bitset>
#include <limits>
#include <cmath> // HUGE_VAL for ::strtod
#include <iostream>

#include "csv_reader.hpp"

#include "scoped_buf.hpp"
#include "file_stream.hpp"

namespace weka {

''')
		
		visitor.instance.write(f, 0)
		f.write('\n\n')
		
		f.write('''// forward declaration - or sort method_chain in usage order
{0};

'''.format(';\n'.join('inline double %s(%s const &%s)' % (method.method_name, InstanceDict.INSTANCE_VARIABLE_TYPE, InstanceDict.INSTANCE_VARIABLE_NAME) for method in visitor.method_chain)))
		
		visitor.method_chain.pop(0).write(f, 0)
		for method in visitor.method_chain:
			f.write('\n')
			method.write(f, 0)
		
		f.write('\n\n}\n\n')
		
		f.write('''inline bool TryConvert(cpcl::StringPiece const &s, std::string &buf, double *r) {{
{0}/* implementation of std::basic_string in msvc stl && gcc libstdc++ implements concept of greedy buffer, 
{0}i.e. memory allocation/deallocation occur only if requested size > capacity() */
{0}buf.assign(s.data(), s.size());
{0}char const *str = buf.c_str();
{0}char *tail;
{0}double const n = ::strtod(str, &tail);
{0}
{0}if ((n == -HUGE_VAL) || (n == +HUGE_VAL) || ((n == 0) && (tail == str)))
{1}return false;
{0}if (r)
{1}*r = n;
{0}return true;
}}
'''.format(InstanceDict.IDENT_CHAR, InstanceDict.IDENT_CHAR * 2))
		
		f.write('''int main(int argc, char **argv) {{
{0}if (argc < 2) {{
{1}std::cerr << "file path to csv data required" << std::endl;
{1}return 1;
{0}}}
'''.format(InstanceDict.IDENT_CHAR, InstanceDict.IDENT_CHAR * 2))
		f.write('''{0}cpcl::FileStream *input_;
{0}if (!cpcl::FileStream::Read(argv[1], &input_)) {{
{1}std::cerr << "unable to read file: " << argv[1] << std::endl;
{1}return 1;
{0}}}
{0}std::auto_ptr<cpcl::FileStream> input(input_);
'''.format(InstanceDict.IDENT_CHAR, InstanceDict.IDENT_CHAR * 2))
		f.write('''{0}typedef cpcl::CsvReader<0x1000> CsvReader;
{0}CsvReader reader(input.get(), true);
{0}CsvReader::FieldIterator field_it, tail;
{0}weka::{1} i;
{0}std::string strtod_buf;
{0}while (reader.Next(&field_it)) {{
'''.format(InstanceDict.IDENT_CHAR, InstanceDict.INSTANCE_VARIABLE_TYPE))
		field = 0
		for i in sorted(visitor.instance.keys()):
			while field < i:
				f.write('''{0}if (field_it == tail) {{
{1}std::cerr << "too few fields" << std::endl;
{1}return 1;
{0}}}
{0}++field_it;
'''.format(InstanceDict.IDENT_CHAR * 2, InstanceDict.IDENT_CHAR * 3))
				field += 1
			f.write('''{0}if (field_it == tail) {{
{1}std::cerr << "too few fields" << std::endl;
{1}return 1;
{0}}}
{0}if ((*field_it).empty())
{1}{set_null_item};
'''.format(InstanceDict.IDENT_CHAR * 2, InstanceDict.IDENT_CHAR * 3,
			   set_null_item = visitor.instance.generate_null_items_set(i)))
			if visitor.instance[i] == 'Double':
				f.write('''{0}else {{
{1}if (!TryConvert(*field_it, strtod_buf, &{selector})) {{
{2}std::cerr << "unable to convert " << *field_it << " to a double" << std::endl;
{2}return 1;
{1}}}
{0}}}
{0}++field_it;
'''.format(InstanceDict.IDENT_CHAR * 2, InstanceDict.IDENT_CHAR * 3,
			   InstanceDict.IDENT_CHAR * 4,
			   selector = visitor.instance.generate_selector(i)))
			else:
				f.write('''{0}else
{1}{selector} = *field_it;
{0}++field_it;
'''.format(InstanceDict.IDENT_CHAR * 2, InstanceDict.IDENT_CHAR * 3,
			   selector = visitor.instance.generate_selector(i)))
#			   set_null_item = visitor.instance.generate_null_items_set(i),
#			   selector = visitor.instance.generate_selector(i),
#			   value = 'cpcl::try_cast<double>(*field_it)' if visitor.instance[i] == 'Double' else '*field_it'))
#			f.write('''{0}if (field_it == tail) {{
#{1}std::cerr << "too few fields" << std::endl;
#{1}return 1;
#{0}}}
#{0}if ((*field_it).empty())
#{1}{set_null_item};
#{0}else
#{1}{selector} = {value};
#{0}++field_it;
#'''.format(InstanceDict.IDENT_CHAR * 2, InstanceDict.IDENT_CHAR * 3,
#			   set_null_item = visitor.instance.generate_null_items_set(i),
#			   selector = visitor.instance.generate_selector(i),
#			   value = 'cpcl::try_cast<double>(*field_it)' if visitor.instance[i] == 'Double' else '*field_it'))
			field += 1
		f.write('''
{1}std::cout << {entry}(i) << std::endl; // if binary classificator(i.e. 2 classes): int(floor(entry_point(i) + 0.1))
{0}}}
{0}return 0;
}}
'''.format(InstanceDict.IDENT_CHAR, InstanceDict.IDENT_CHAR * 2, entry = visitor.entry_point))
			# CSVReader { bool Next(FieldIterator *field_it); }
			# CSVReader::FieldIterator { bool Next(cpcl::StringPiece *field); }
	
if __name__ == '__main__':
	main()
